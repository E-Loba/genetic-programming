cmdhistory=["(count deck)" "(rand-nth deck)" "(get deck \:Queen)" "(get deck \:values)" "(get deck \:suit)" "(def deck (produce_deck suits values))" "(def hand (repeatedly 12 (rand-nth deck )))" "hand" "(pprint hand)" "(print hand)" "(repeatedly 12 (rand-nth deck))" "deck" "(repeatedly 12 (rand-nth (seq deck) ) )" "(seq deck)" "(repeatedly 12 ((rand-nth (seq deck) \:value)) )" "(repeatedly 12 ((rand-nth (seq deck) ) \:value ))" "(next deck)" "(first deck)" "(rand-nth deck)" "(repeatedly 12 \#(rand-nth deck))" "(def mycard {\:suit 'Diamonds, \:vlaue 10})" "(remove (\= mycard) deck )" "(shuffle deck)" "(list [1 2 3] [4 5 6])" "(def mylist [1 2])" "(def newlist [ 3 4])" "(cons mylist newlist)" "(list mylist newlist)" "(def myseq (seq 1 2 3))" "(def myseq (seq [1 2 3]))" "(def newseq (seq [4 5 6]))" "(list newseq myseq)" "(def mymap {\:key1 'value1 \:key2 'value2 })" "(def newmap (remove \:key1 mymap))" "newmap" "(mymap \:key1)" "(def mykey \:key1)" "(mymap mykey)" "(let [x 5] (let [y (+ x 5)] (print y)) (print x) )" "(let [x 5] (let [y (+ x 5)] (print y)) (print y) )" "(let [x 5] (let [x (+ x 3)] (print x)) (print x) )" "(< 4 5)" "(if (true) 4 5 )" "(if true)" "(if (< 4 5) 4 5)" "(def var (cons 1 (repeatedly 4 \#('a))))" "var" "(def var (cons 1 (repeatedly 4 \#(+ 2 1))))" "var" "(def arr (seq [1 2 3]))" "arr" "(def var (cons 1 (repeatedly 4 \#(cons 1 arr))))" "var" "(def mymap {\:key1 1 \:key2 2 \:key3 3})" "(def newmap {mymap \:key4 4} )" "(def x 10)" "(inc x)" "x" "(remove (not\= \:key1 ) mymap)" "(remove (not\= \:key1 item ) mymap)" "(remove (fn [x] (not\= \:key1 (key x)) ) mymap)" "(def deck (produce-deck suits values) )" "(def situation {\:hand deck \:trump 'Clubs} )" "(number-of-trumps situation )" "(def deck (produce-deck suits values))" "(def situation {\:hand deck \:trump 'Clubs} )" "(number-of-trumps situation)" "(def deck (produce-deck suits values))" "(def situation {\:hand deck \:trump 'Clubs})" "(number-of-trumps situation)" "(def deck (produce-deck suits values) )" "(def situation {\:hand deck \:trumps 'Hearts})" "(number-of-suit situation 'Hearts)" "(def deck (produce-deck suits values))" "(def situation {\:hand deck \:trumps 'Hearts})" "(number-of-suit situation 'Hearts)" "(number-of-trumps situation 'Hearts)" "(number-of-trumps situation)" "(cons 1 (repeatedly 3 (cons (inc 1))) )" "(cons 1 (repeatedly 3 (cons 2 (seq [3 4]))) )" "(cons 1 (repeatedly 3 seq [3 4]))" "(cons 1 (repeatedly 3 (seq [3 4])))" "(cons 1 (repeatedly 3 \#(cons 1 [3 4])))" "(cons 1 (repeatedly 3 \#(seq [2 3 4])))" "(cons 1 (seq (seq [2 3 4])))" "(cons 1 (cons 2 [3 4]))" "(cons 1 (repeatedly 1 \#(cons 2 [3 4])))" "(cons 1 (seq [2 3 4]))" "(cons 1 (cons 1 (cons 1 'a)))" "(rand-nth [1 2 3 4 5])" "(cons 1 (cons 2 (cons 3 (rand-nth [4 5 6]))))" "(cons 3 (rand-nth [4 5 6]))" "(cons 3 4)" "(cons 'a 'b)" "(seq 1)" "(seq [1])" "(seq (list 1))" "(seq [(+ 1 2)])" "(cons 1 (seq (cons 2 (seq (cons 3 (seq ['a]))))))" "(cons 1 (cons 1 (seq ['a])))" "(seq (seq [1]))" "(repeatedly 2 \#(seq [1 2]))" "(seq (seq [1 2]) (seq [3 4]) )" "(cons (seq [1 2]) (seq [3 4]) )" "(cons (seq [1 2]) (cons 3 (seq [4 5] ) ) )" "(+ (seq [1 2]))" "(def mymap {\:key1 1 \:key2 2})" "(let [[var1 var2] mymap] (print var1) (print var2))" "(def deck (produce-deck suits values))" "(def mycard (rand-nth deck))" "(remove (fn [x] (\= x mycard)) deck )" "mycard" "(def deck (produce-deck suits values))" "(def mydeck (produce-deck suits values))" "(def myhand (deal-hand deck 12))" "(def myhand (deal-hand mydeck 12))" "(def mydeck (produce-deck suits values))" "(def myhand (deal-hand mydeck 12))" "myhand" "(last myhand)" "(cons 1)" "(seq [1])" "(cons {\:ke1 1} (seq [{\:ke2 2}]))" "(def myhand (deal-hand mydeck 12))" "myhand" "(produce-deck 1 2)" "(def mydeck (produce-deck))" "mydeck" "(def mymap {\:key1 1 \:key2 2 \:key3 3})" "(def mykeys [\:key1 \:key2 \:key3])" "(mymap (rand-nth mykeys))" "(repeatedly 3 \#(inc 1))" "(let [args [1 2 3 4]] (for [x (range (count args)) y args] (cons y (rest args))))" "(list 'fn 'Terminal 'tree)" "(eval (list 'fn ['situation]\\r\\n                     (list 'let \\r\\n                           ['play (list 'situation \:play)\\r\\n                            'hand (list 'situation \:hand)\\r\\n                            'discard (list 'situation \:discard)\\r\\n                            'mode (list 'situation \:mode)\\r\\n                            'trump (list 'situation \:trump)]\\r\\n                           tree)))" "(list 'fn ['situation]\\r\\n                        (list 'let \\r\\n                              ['play (list 'situation \:play)\\r\\n                               'hand (list 'situation \:hand)\\r\\n                               'discard (list 'situation \:discard)\\r\\n                               'mode (list 'situation \:mode)\\r\\n                               'trump (list 'situation \:trump)]\\r\\n                              'tree))" "(list 'fn ['situation] (list 'let ['play (list 'situation \:play) 'hand (list 'situation \:hand) 'discard (list 'situation \:discard) 'mode (list 'situation \:mode) 'trump (list 'situation \:trump)] tree))" "(list 'fn ['situation] (list 'let ['play (list 'situation \:play) 'hand (list 'situation \:hand) 'discard (list 'situation \:discard) 'mode (list 'situation \:mode) 'trump (list 'situation \:trump)] 'tree))" "(def mydeck (produce-deck))" "(def myhand (deal-hand deck 12))" "(def myhand (deal-hand mydeck 12))" "(def mycards (get-suit myhand (first mydeck)))" "mycards" "(remove nil? mycards)" "(def mycards (get-suit myhand (first mydeck)))" "mycards" "(get-suit myhand {\:suit 'Circles})" "(empty? (get-suit mydeck {\:suit 'Circles}))" "(def nums [1 2 3 4 5 6 7 8 9 0])" "(filter even? nums)" "(empty? (get-suit mydeck {\:suit 'Circles}))" "(get-suit myhand {\:suit 'Circles})" "(get-suit myhand {\:suit 'Hearts})" "(get-suit myhand {\:suit 'Spades})" "(get-suit myhand {\:suit 'Clubs})" "(get-suit myhand {\:suit 'Diamonds})" "(if-let [nums (get-suit myhand {\:suit 'Diamonds})]\\r\\n           \\"I have diamonds\\"\\r\\n           \\"No even numbers found.\\")" "(if-let [nums (get-suit myhand {\:suit 'Diamonds})]\\r\\n              nums\\r\\n              myhand)" "(if-let [nums (get-suit myhand {\:suit 'Circles})]\\r\\n                 nums\\r\\n                 myhand)" "(if-let [nums (seq (get-suit myhand {\:suit 'circles}))]\\r\\n                 nums\\r\\n                 myhand)" "(list 'fn ['situation]\\r\\n                     (list 'let \\r\\n                           ['play (list 'situation \:play)\\r\\n                           'trump (list 'situation \:trump)\\r\\n                           'discard (list 'situation \:discard)\\r\\n                           'mode (list 'situation \:mode)\\r\\n                           'hand (list 'if-let\\r\\n                                       [suits-hand (list 'seq\\r\\n                                                         (list 'cons\\r\\n                                                               (list 'get-suit (list 'situation \:hand) 'play)\\r\\n                                                               (list 'get-suit (list 'situation \:hand) 'trumps)))]\\r\\n                                       (suits-hand)\\r\\n                                       (list 'situation \:hand))]\\r\\n                     'tree))" "(list 'fn ['situation]\\r\\n                     (list 'let \\r\\n                           ['play (list 'situation \:play)\\r\\n                           'trump (list 'situation \:trump)\\r\\n                           'discard (list 'situation \:discard)\\r\\n                           'mode (list 'situation \:mode)\\r\\n                           'hand (list 'if-let\\r\\n                                       ['suits-hand (list 'seq\\r\\n                                                         (list 'cons\\r\\n                                                               (list 'get-suit (list 'situation \:hand) 'play)\\r\\n                                                               (list 'get-suit (list 'situation \:hand) 'trumps)))]\\r\\n                                       ('suits-hand)\\r\\n                                       (list 'situation \:hand))]\\r\\n                     'tree))" "(list 'fn ['situation]\\r\\n                        (list 'let \\r\\n                              ['play (list 'situation \:play)\\r\\n                              'trump (list 'situation \:trump)\\r\\n                              'discard (list 'situation \:discard)\\r\\n                              'mode (list 'situation \:mode)\\r\\n                              'hand (list 'if-let\\r\\n                                          ['suits-hand (list 'seq\\r\\n                                                            (list 'cons\\r\\n                                                                  (list 'get-suit (list 'situation \:hand) 'play)\\r\\n                                                                  (list 'get-suit (list 'situation \:hand) 'trumps)))]\\r\\n                                          (seq ['suits-hand])\\r\\n                                          (list 'situation \:hand))]\\r\\n                        'tree))" "(if-let [nums (seq (get-suit myhand nil))]\\r\\n                    nums\\r\\n                    myhand)" "(if-let [nums (seq (get-suit myhand {\:suit 'circles}))]\\r\\n                    nums\\r\\n                    myhand)" "(get-suit myhand {\:suit 'circles})" "(get-suit myhand nil)" "(not (zero? (count (get-suit myhand {\:suit 'Diamonds}))))" "(high-cards myhand)" "(for [x 0] (print x))" "(for [x (range 0)] (print x))" "(def myvar {\:choice 'no-trumps})" "(\= myvar \:choice)" "(def mymap {\:key1 1 \:key2 2 \:key3 3})" "(apply max mymap)" "(find (max (vals mymap)))" "(max (vals mymap))" "(max-key mymap)" "(apply max (mymap))" "(apply max mymap)" "(apply max (vals mymap))" "(def mydeck (produce-deck))" "(def myhand (deal-hand deck 12))" "(def myhand (deal-hand mydeck 12))" "(get-most-suit hand 'suit)" "(get-most-suit myhand 'suit)" "(get-suit myhand {\:suit 'Spades})" "(def myseq (seq [1 2 3 4]))" "(max myseq)" "(apply max myseq)" "(apply min myseq)" "(reverse (sort [4 7 3 9 5 0 3]))" "(cons 1 (seq [2 3 4 5 6]))" "(cons 1 [2 3 4 5 6])" "(cons 1 (list [2 3 4 5 6]))" "(cons 1 (seq (list [2 3 4 5 6])))" "(def mydeck (produce-deck))" "(def deck-hand (let [x (deal-hand mydeck 12)] [(butlast x) (last x)]))" "(first deck-hand)" "(last deck-hand)" "(def mymodule (create-module 10 \:card))" "mymodule" "(def mymodule (create-module 10 \:play))" "(print mymodule)" "(def myfunc (compile-module mymodule))" "mymodule" "(count 'a)" "(def mymodule (create-module 10 \:play))" "mymodule" "(def myfunc (compile-module mymodule))" "(rand-nth 'a)" "(def mymodule (create-module 10 \:play))" "mymodule" "(rand-nth ['a])" "(def mymodule (create-module 10 \:play))" "mymodule" "(def mymodule (create-module 10 \:play))" "mymodule" "(def mymodule (create-module 10 \:play))" "mymodule" "(def mymodule (create-module 10 \:play))" "myfunc" "mymodule" "(for [x 5 y [1 2 3 4 5]] (print [x y]))" "(for [x (range 5) y [1 2 3 4 5]] (print [x y]))" "(let [y [1 2 3 4 5]] (for [x (range 5)] (print [x (nth x y)])))" "(for [x (range 5)] (print x))" "(let [y [1 2 3 4 5]] (for [x (range 5)] (nth x y)))" "(let [x (range 5)] (print x))" "(for [x (range 3) y (range 3)] [x y])" "(let [y [1 2 3 4 5]] (for [x (range 5)] (nth y x)))" "(def mymodule (create-module 5 \:play))" "mymodule" "(nth [1 2 3 4 5] 0)" "(nth [1 2 3 4 5] 1)" "(def mymodule (create-module 5 \:play))" "mymodule" "(print mymodule)" "(4)" "('a)" "(def a 'a)" "(a)" "(def mymodule (create-module 5 \:play))" "mymodule" "(for [x (range 5)] 'a)" "(for [x (range 5)] \:a)" "(cons 'b (for [x (range 5)] 'a))" "(create-module 3 \:boole)" "(compile-module (create-module 3 \:choice))" "(def mymod (create-module 5 \:play))" "mymod" "(def myfunc (compile-module mymod))" "(defn myfun\\r\\n  [depth type]\\r\\n  (cond (zero? depth) (rand-nth ({\:a ['a] \:b ['b]} type))\\r\\n        \:else (let [[fun args] (rand-nth ({\:a '[[+ [\:a \:b]]] \:b '[[- [\:b \:a]]]} type))]\\r\\n                (cons fun\\r\\n                      (for [x (range (count args))]\\r\\n                        (myfun (dec depth) (nth args x)))))))" "(myfun 3 \:a)" "(def myfun2 (eval (list 'fn ['a 'b] myfun)))" "(myfun2 0 1)" "(def myfun2 (eval (list 'fn ['a 'b] (myfun 3 \:a))))" "(myfun2 0 1)" "\:hand" "\:trump" "(def mymod (create-module 5 \:play))" "mymod" "(let [[a b] [1 [2 3]]] (nth b a))" "(nth 'a)" "(nth 'a 0)" "(functions \:card)" "(rand-nth (functions \:card))" "(rand-nth (functions \:hand))" "(count (last (rand-nth (functions \:card))))" "(rand-nth 'a)" "(rand-nth (terminals \:card))" "(def mymod (create-module 5 \:play))" "mymod" "(def mydeck (produce-deck))" "(def hand-deck (deal-hand mydeck 12))" "(def myhand (first hand-deck))" "myhand" "(def myhand (butlast hand-deck))" "myhand" "(sort-by \:value myhand)" "(def mystring \\"Ace\\")" "mystring" "(sort-by (fn [x] (parse-value x false)) myhand)" "(sort-by card-comparator myhand)" "(def mymod (create-module 5 \:play))" "mymod" "(def mysit (let [myh (deal-hand mydeck 12)\\n                 hand1 (butlast myh)\\n                 temp (deal-hand (last myh) 12)\\n                 discard1 (butlast temp)\\n                 play1 (first (last temp))]\\n             {\:play play1 \:hand hand1 \:discard discard1 \:misere false \:trump 'Hearts}))" "mysit" "(def myfunc (compile-module mymod))" "myfunc" "(myfunc mysit)" "(def mymode (compile-module (create-module 3 \:mode)))" "(mymode mysit)" "(def mymode (create-module 3 \:mode))" "mymode" "(def mymode (compile-module (create-module 3 \:mode)))" "(def mymode (create-module 3 \:mode))" "mymode" "(def mymode2 (compile-module (create-module 3 \:mode)))" "(def mymode (compile-module mymode))" "(def a ''a)" "a" "(def mymode (compile-module mymode))" "(def mymode (create-module 3 \:mode))" "mymode" "(def mymode (create-module 3 \:mode))" "mymod" "mymode" "(def mymode (compile-module mymode))" "(mymode mysit)" "(def hand-deck (deal-hand (produce-deck) 12))" "(def myhand (butlast hand-deck))" "(def mydeck (last hand-deck))" "(def dis-deck (deal-hand mydeck 12))" "(def mydis (butlast dis-deck))" "mydis" "(def mydeck (last dis-deck))" "(def mysit {\:play (first mydeck) \:hand myhand \:discard mydis \:trump 'Spades \:misere false})" "(def mymodule (create-module 5 \:play))" "mymodule" "(def myfunc (compile-respond mymodule))" "(myfunc mysit)" "myfunc" "(def myfunc (compile-respond mymodule))" "(myfunc mysit)" "(def myfunc (compile-respond mymodule))" "(myfunc mysit)" "mymodule" "(def mymodule (create-module 3 \:play))" "(def myfunc (compile-respond mymodule))" "(myfunc mysit)" "(mysit \:play)" "(def myfunction (create-module 3 \:play))" "myfunction" "(def mycompile (compile-respond myfunction))" "(mycompile mysit)" "(mysit \:play)" "(mysit \:hand)" "(def myf1 (create-module 5 \:discard))" "myf1" "(def mypl1 (compile-module myfun1))" "(def mypl1 (compile-module myf1))" "(mypl1 mysit)" "(def myf1 (create-module 5 \:discard))" "(def mypl1 (compile-module myf1))" "(mypl1 mysit)" "(def myf1 (create-module 5 \:discard))" "(def mypl1 (compile-module myf1))" "(mypl1 mysit)" "(distinct ({\:a 1} {\:a 2}))" "(\= {\:a 1} {\:a 2})" "(distinct '({\:a 1} {\:a 2}))" "(distinct (seq [{\:a 1} {\:a 2}]))" "(concat [{\:a 1} {\:a 2}] [{\:a 3} {\:a 4}])" "(distinct (concat [{\:a 1} {\:a 2}] [{\:a 3} {\:a 3}]))" "(distinct (seq (concat [{\:a 1} {\:a 2}] [{\:a 3} {\:a 3}])))" "(def mydeck (produce-deck))" "(let [[a b] (deal-hand mydeck 8)] [a b])" "(let [a (butlast (deal-hand mydeck 8))] [a (difference a mydeck)])" "(join \#({\:suit 'Spades \:value 'Ace} {\:suit 'Hearts \:value 5}))" "(join \#({\:suit 'Spades \:value 'Ace}) \#({\:suit 'Hearts \:value 5}))" "(join {\:suit 'Spades \:value 'Ace} {\:suit 'Hearts \:value 5})" "(join \#{{\:suit 'Spades \:value 'Ace}} \#{{\:suit 'Hearts \:value 5}})" "(union \#{{\:suit 'Spades \:value 'Ace}} \#{{\:suit 'Hearts \:value 5}})" "(def mydeck (set (produce-deck)))" "(def myhand (set (butlast (deal-hand mydeck 8))))" "mydeck" "(count mydeck)" "(def mypl (construct-player 1 2 3 4 5 6 7))" "mypl" "(class mypl)" "(class \:a)" "(return-discard [{\:suit 'Hearts \:value 4} {\:suit 'Clubs \:value 3}]\\n                [{\:suit 'Hearts \:value 'Ace}]\\n                [{\:suit 'Clubs \:value 7}]\\n                [{\:suit 'Spades \:value 9}]\\n                [{\:suit 'Hearts \:value 4} {\:suit 'Clubs \:value 'King}]\\n                [{\:suit 'Spades \:value 10}])" "(def hand-deck (deal-hand (produce-deck) 12))" "(def hand (butlast hand-deck))" "(def mydeck (last hand-deck))" "(def mysit {\:hand hand \:deck mydeck \:play nil \:trump 'Spades \:misere false})" "(def mymod (create-module 3 \:discard))" "mymod" "(def myfunc (compile-module mymod))" "(myfunc mysit)" "(mysit {\:hand hand \:deck mydeck \:play nil \:trump 'Spades \:misere false \:discard nil})" "(def mysit {\:hand hand \:deck mydeck \:play nil \:trump 'Spades \:misere false \:discard nil})" "(myfunc mysit)" "(def mymod (create-module 3 \:discard))" "(def myfunc (compile-module mymod))" "(myfunc mysit)" "(def mymod2 (create-module 3 \:discard))" "(def myfunc2 (compile-module mymod2))" "(myfunc2 mysit)" "(def mydeck (produce-deck))" "(def hand-deck (deal-hand mydeck 12))" "(def myhand (butlast hand-deck))" "(def mydeck (last hand-deck))" "(def mysit {\:hand myhand \:discard nil \:play nil \:trump nil \:misere true})" "(def mymod (create-module 3 \:discard))" "(def myfunc (compile-module mymod))" "(myfunc mysit)" "(+ nil 1)" "(deal-hand nil 12)" "(def mymod3 (create-module 3 \:choice))" "(def mymod3 (create-module 3 \:mode))" "(def myfunc3 (compile-module mymod3))" "(myfunc3 mysit)" "(def mysit {\:discard nil\\n            \:hand [{\:suit 'Hearts \:value 10} {\:suit 'Spades \:value 3} {\:suit 'Clubs \:value 'Ace} {\:suit 'Diamonds \:value 'King} {\:suit 'Hearts \:value 6} {\:suit 'Hearts \:value 7}\\n                   {\:suit 'Spades \:value 10} {\:suit 'Diamonds \:value 3} {\:suit 'Clubs \:value 'Queen} {\:suit 'Diamonds \:value 2} {\:suit 'Hearts \:value 5} {\:suit 'Diamonds \:value 7}]\\n            \:trump nil\\n            \:misere true\\n            \:play nil})" "(def mymod (create-module 3 \:discard))" "(def myfunc (compile-module mymod))" "(myfunc mysit)" "(def mymod2 (create-module 3 \:choice))" "(def myfunc2 (compile-module mymod2))" "(myfunc2 mysit)" "(def mysit {\:discard [null-card]\\r\\n               \:hand [{\:suit 'Hearts \:value 10} {\:suit 'Spades \:value 3} {\:suit 'Clubs \:value 'Ace} {\:suit 'Diamonds \:value 'King} {\:suit 'Hearts \:value 6} {\:suit 'Hearts \:value 7}\\r\\n                      {\:suit 'Spades \:value 10} {\:suit 'Diamonds \:value 3} {\:suit 'Clubs \:value 'Queen} {\:suit 'Diamonds \:value 2} {\:suit 'Hearts \:value 5} {\:suit 'Diamonds \:value 7}]\\r\\n               \:trump nil\\r\\n               \:misere true\\r\\n               \:play null-card})" "(myfunc2 mysit)" "(def myvar (create-module 7 \:play))" "myvar" "(rand-subtree myvar)" "(def myfunc (compile-module (rand-subtree myvar)))" "(myfunc {\:play nil \:hand (produce-deck) \:discard (produce-deck) \:misere True \:trump nil})" "(myfunc {\:play nil \:hand (produce-deck) \:discard (produce-deck) \:misere true \:trump nil})" "(def myfunc2 myvar)" "(butlast (deal-hand (produce-deck)))" "(butlast (deal-hand (produce-deck) 9))" "(def mysit {\:play nil \:hand (butlast (deal-hand (produce-deck) 9)) \:discard (produce-deck) \:misere true \:trump nil})" "(myfunc2 mysit)" "(def myfunc2 (compile-module myvar))" "(myfunc2 mysit)" "(def mysit {\:play {\:suit 'Diamonds \:value 6} \:hand (butlast (deal-hand (produce-deck) 9)) \:discard (produce-deck) \:misere true \:trump nil})" "(myfunc2 mysit)" "(def myvar (create-module 4 \:play))" "(def myfunc (compile-module myvar))" "(def mysit (let [discard (deal-hand (produce-deck) 6) hand (deal-hand (last discard) 13) ]\\n  {\:play {\:suit 'Hearts \:value 10}\\n   \:deck (last hand)\\n   \:discard (butlast discard)\\n   \:hand (butlast hand)\\n   \:trump 'Diamonds\\n   \:misere false}))" "(myfunc mysit)" "(try (myfunc mysit)\\r\\n    (catch RuntimeException E -1)\\r\\n    (catch Exception X -1))" "myvar" "(def myvar2 (rand-subtree myvar))" "(def myfunc2 (compile-module myvar2))" "(try (myfunc2 mysit)\\r\\n       (catch RuntimeException E -1)\\r\\n       (catch Exception X -1))" "myvar2" "(myfunc2 mysit)" "(mysit \:hand)" "(map? (mysit \:play))" "(contains? mysit \:trump)" "(contains? mysit \:value)" "(count (mysit \:play))" "(and true true true false)" "(+ 1 2 3 4 5)" "(or true true true false)" "(instance? false (class true))" "(class true)" "(instance? (class true) (myfunc mysit))" "(def myvar3 (create-module 5 \:discard))" "(def myfunc3 (compile-module myvar3))" "(myvar3 mysit)" "myvar3" "(try (myfunc3 mysit)\\r\\n          (catch RuntimeException E -1)\\r\\n          (catch Exception X -1))" "(myfunc3 mysit)" "(def myvar3 (create-module 3 \:discard))" "myvar3" "(def myfunc3 (compile-module myvar3))" "(myfunc3 mysit)" "(def mylist '(1 2 3 4 5 6))" "(< 6 (count mylist))" "(try (myfunc3 mysit)\\r\\n             (catch RuntimeException E -1)\\r\\n             (catch Exception X -1))" "(take-nth 3 '(1 2 3 4 5))" "(def myarray '(1 2 3 4 5 6 7 8 9 0))" "(first myarray)" "(first (rest myarray))" "(nth myarray 2)" "(nth myarray 0)" "(def myarray2 '('apple 'pear 'orange 'cherry 'melon))" "(some \#{'apple} myarray2)" "(\#{'apple})" "\#{'apple}" "(\#{'apple} 'apple)" "myarray2" "(def myarray2 (list 'apple 'pear 'orange 'cherry 'melon))" "myarray2" "(some \#{'apple} myarray2)" "(def apple 'apple)" "(some \#{apple} myarray2)" "(some \#{nil} (list 'chice 'misere 'spades-as-trumps 'no-trumps))" "(ismode? nil (list 'misere 'choice 'spades-as-trumps 'no-trumps))" "(def mymodes (list 'misere 'choice 'trumps-as-spades 'no-trumps))" "(ismode? nil mymodes)" "(ismode? 'misere mymodes)" "(def mychoices (list 'misere 'no-trumps 'Spades 'Hearts 'Diamonds 'Clubs))" "(ismode? 'Hearts mychoices)" "(ismode? 'Trumps mychoices)" "(class 'Diamonds)" "(class mymodes)" "(def mymap {\:key1 1 \:key2 2})" "(get mymap \:key3)" "(get mymap \:key2)" "(def mymap {\:key1 +})" "((get mymap \:key1) 1 1)" "(find-keyword \:modes)" "(find-keyword \:aliens)" "(find-keyword \\"mode\\")" "(find-keyword \\"dark-knights\\")" "(.find Keyword \\"mode\\")" "((get mymap (find-keyword \\"key1\\")) 1 1)" "(.find clojure.lang.Keyword \\"mode\\")" "(Keyword/find \\"mode\\")" "(clojure.lang.Keyword/find \\"mode\\")" "(clojure.lang.Keyword/find \\"test-test.core\\" \\"mode\\")" " (clojure.lang.Keyword/find \\"test-test.game\\" \\"mode\\")" " (clojure.lang.Keyword/find \\"test-test.funcs\\" \\"mode\\")" " (clojure.lang.Keyword/find test-test.core \\"mode\\")" " (clojure.lang.Keyword/find (ns test-test.core) \\"mode\\")" "(class (produce-deck))" "butlast" "(list 'a (list 1 2 3 4 5))" "(concat 'a (list 1 2 3 4 5))" "(remove \#{'a} (list 'a 'b 'c 'd))" "(def mydeck (produce-deck))" "(remove \#{{\:suit 'Diamonds \:value 'King}} mydeck)" "(empty? deck)" "(empty? mydeck)" "(empty? '())" "(def mycard {\:suit 'Diamonds \:value 'Queen})" "(def myhand (list {\:suit 'Hearts \:value 'Queen}\\n                  {\:suit 'Clubs \:value 'Queen}\\n                  {\:suit 'Spades \:value 'Queen}\\n                  {\:suit 'Diamonds \:value 'Queen}\\n                  {\:suit 'Trumps \:value 'Queen}))" "(remove-card mycard myhand)" "(.rand java.math)" "(java.math/random)" "java.lang.Math" "(java.lang.Math/random)" "(class true)" "(some \#{1} (list 1 2 3 4 5 6 7 8))" "(some \#{1 2 3 4 5} (list 1 2 3 4 5 6 7 8))" "(some \#{1 3 5 7} '(2 4 6 5))" "(rest '(1))" "(defn remove-group\\n  [group items-set]\\n  (if (\= 1 (count items-set)) (list (some \#{(first items-set)} group))\\n        (concat (list (some \#{(first items-set)} group)) (remove-group group (rest items-set))) \\n        ))" "(remove-group '(1 2 3 4 5) '(0 1 2 3 4 5 6 7 8 9))" "(defn remove-group\\r\\n     [group items-set]\\r\\n     (if (empty? items-set) ()\\r\\n           (concat (if (nil? (some \#{(first items-set)} group)) () (first items-set))\\n                     (remove-group group (rest items-set)) )))" "(remove-group '(1 2 3 4 5) '(0 1 2 3 4 5 6 7 8 9))" "(defn remove-group\\r\\n        [group items-set]\\r\\n        (if (empty? items-set) ()\\r\\n              (concat (if (nil? (some \#{(first items-set)} group)) () (list (first items-set)))\\r\\n                        (remove-group group (rest items-set)) )))" "(remove-group '(1 2 3 4 5) '(0 1 2 3 4 5 6 7 8 9))" "(defn remove-group\\r\\n           [group items-set]\\r\\n           (if (empty? items-set) ()\\r\\n                 (concat (if (some? (some \#{(first items-set)} group)) () (list (first items-set)))\\r\\n                           (remove-group group (rest items-set)) )))" "(remove-group '(1 2 3 4 5) '(0 1 2 3 4 5 6 7 8 9))" "(import WhistGame.java)" "(import WhistGame)" "(import 'test-test.WhistGame)" "(import Game)" "(.playWhist WhistGame)" "(.random Math)" "(.random java.lang.Math)" "(.random() java.lang.Math)" "Math/PI" "(.random Math)" "Math/random" "Math/random()" "(Math/random)" "WhistGame" "Math" "test-test.core-test" "test-test.core" "(import test-test.funcs)" "(import src.test_test.WhistGame)" "(import WhistGame)" "(import resources WhistGame)" "(import test_test.WhistGame)" "(import java.lang.Math)" "(import 'test_test.WhistGame)" "(import 'WhistGame)" "(System/getProperty \\"user.dir\\")" "(import src.test_test.WhistGame)" "(import mythings)" "mythings" "(import test-test.things)" "test-test.things" "(macroexpand-1 '(import java.lang.Math))" "(macroexpand-1 '(ns test-test.things))" "WhistGame" "(import WhistGame)" "(import test_test.target.WhistGame)" "(import test_test.src.WhistGame)" "(import test_test.)" "test_test." "WhistGame" "(.playWhist WhistGame)" "(WhistGame/playWhist)" "(Math/random)" "(Math/abs)" "test_test." "(test_test.WhistGame)" "(test_test.WhistGame/playWhist)" "(Math/abs -12)" "(test_test.WhistGame/dummy)" "(def myvar (create-module 5 \:discard))" "myvar" "(rand-subtree myvar)" "(def mysubtree (rand-subtree myvar))" "(first mysubtree)" "myplayer1-tree" "(defn compile-player\\n  [player-tree]\\n  (let [mydiscard (compile-module (player-tree \:discard))\\n        mypeek (compile-module (player-tree \:peek))\\n        mymode (compile-mode (player-tree \:mode))\\n        mychoice (compile-module (player-tree \:choice))\\n        mylead (compile-module (player-tree \:lead))\\n        mydolead (compile-module (player-tree \:dolead))\\n        myrespond (compile-respond (player-tree \:respond))]\\n    {\:discard mydiscard \:peek mypeek \:mode mymode \:choice mychoice \:lead mylead \:dolead mydolead \:respond myrespond}))" "(def myplayer-compiled (compile-player myplayer1-tree))" "myplayer-compiled" "(test_test.WhistGame/playWhist player1 player2)" "(player1 \:peek)" "(test_test.WhistGame/playWhist player1 player2)" "(test_test.WhistGame/playWhist (compile-player myplayer1-tree) (compile-player myplayer2-tree))" "(find-var 'null-card)" "null-card" "(class null-card)" "while" "nil?" "nil" "(read)" "(eval (read))" "(test_test.WhistGame/playWhist player1 player2)" "(play-whist player1 player2)" "(print \\"here\\")" "(print \\"\\\\nhere\\\\nhere\\\\n\\")" "(play-whist player1 player2)" "((player1 \:discard) (produce-deck))" "(player1 \:discard)" "(produce-deck)" "(\#(player1 \:discard) (produce-deck))" "(myplayer1-tree \:discard)" "(def mysit {\:play null-card \:hand (produce-deck) \:discard nil \:misere false \:trump 'Spades})" "((player1 \:discard) mysit)" "(list a)" "(list 'a)" "(dec 1)" "(create-generation 3 2 2 2 2 2 3 3)" "(def myseq (seq (sort (list 3 4 5 6 7 8))))" "myseq" "(def myseq2 (reverse myseq))" "myseq2" "(def myseq3 (sort myseq2))" "myseq3" "(\= myseq myseq3)" "(\= myseq2 myseq3)" "(take 6 '(1 2 3 4 5))" "(take 6 '(1 2 3))" "(def step 1)" "'(step)" "step" "(list step)" "(def mylist '(0 1 2 3 4 5 6 7 8 9))" "(nth mylist 0)" "(some \#{1} '(1 1 1 2 2 3 1))" "(some (fn [x] (\= x 1)) '(1 2 3 4 1))" "(\= (sort (list 4 3 2 1)) '(1 2 3 4))" "(or 1 2)" "(or 2 1)" "(and 1 2)" "(and 1 2 3)" "(and 1 3 2)" "(extract-winners '(1 1 1 2 1 2) '('a 'b 'a 'b 'a 'b 'a 'b 'a 'c 'a 'b) )" "(extract-winners '(1 1 1 2 1 2) '('a 'b 'a 'b 'a 'b 'a 'b 'a 'c 'a 'b 'c) )" "(<\= 0 -1)" "(>\= 0 -1)" "(<\= -1 0)" "(extract-winners '(1 2) ('a 'b 'c))" "(extract-winners '(1) ('a 'b 'c))" "(extract-winners '(1 2) '('a 'b 'c))" "(extract-winners '(1) '('a 'b 'c))" "(extract-winners '(1) '('a))" "(\= + +)" "(\= \= \=)" "'(\= \=)" "'(\:hand 'a 'b 'c)" "(def myindex '(\:hand 'a 'b 'c))" "(first myindex)" "(\= (first myindex) 'a)" "(def myvar (create-module 3 \:discard))" "myvar" "(def mysit (let [temp (deal-hand (produce-deck) 12)]\\n             {\:play null-card \:hand (butlast temp) \:discard nil \:trump nil \:misere false}))" "(def myplay (compile-player myvar))" "(edf myplay (compile-module myvar))" "(def myvar (create-module 2 \:discard))" "myvar" "(def mysit {\:play null-card \:hand (butlast (deal-hand (produce-deck) 12)) \:discard nil \:trump nil \:misere nil})" "(def myplay (compile-module myvar))" "(myplay mysit)" "(def myvar (create-module 4 \:discard))" "myvar" "(def myplay (compile-module myvar))" "(def mysub (rand-subtree myvar))" "mysub" "(first mysub)" "(some \#{(first mysub)} (nth functions-return-type-index 6))" "(nth functions-return-type-index 6)" "(some \#{low-cards} (nth functions-return-type-index 6))" "(some \#{low-cards} '(low-cards))" "\#{low-cards}" "(macroexpand-1 'a)" "(macroexpand-1 (some \#{low-cards} '(low-cards)))" "(macroexpand-1 '(some \#{low-cards} '(low-cards)))" "(some (fn [x] (\= x low-cards)) (nth functions-return-type-index 6))" "(some (fn [x] (\= x 6)) '(1 2 3 4 5 6 7 8 9 0))" "(nth functions-return-type-index 6)" "(rand-nth (nth functions-return-type-index 6))" "(some \#{low-cards} (nth functions-return-type-index 6))" "(rand-nth (nth functions-return-type-index 6))" "(some (fn [x] (\= x low-cards)) (nth functions-return-type-index 6))" "(nth functions-return-type-index 6)" "(filter (fn [x] (\= x low-cards)) (nth functions-return-type-index 6))" "(nth functions-return-type-index 3)" "(rand-nth (nth functions-return-type-index 3))" "(some \#{\=} '(\= \= \=))" "(list \= \= \=)" "(some \#{\=} (list \= \= \=))" "(nth functions-return-type-index 3)" "(some \#{>} (nth functions-return-type-index 3))" "(def myvar (create-module 4 \:play))" "myvar" "(def mut-var (replace-subtree myvar 0))" "mut-var" "(def ran-var (rand-subtree myvar))" "ran-var" "(def ran-var (rand-subtree myvar))" "ran-var" "(def ran-var (rand-subtree myvar))" "ran-var" "(firat ran-var)" "(first ran-var)" "(identify-sub ran-var)" "(some \#{(first ran-var)} (nth functions-return-type-index 6))" "(identify-sub ran-var)" "(identify-sub 'trump)" "(identify-sub '('trump))" "(- 3 1)" "(first '())" "(identify-sub '('trump))" "(myvar)" "myvar" "(def newvar (replace-subtree myvar 3))" "newvar" "(def newfunc (compile-module newvar))" "(def mysit {\:hand (butlast (deal-hand (produce-deck) 12))\\n            \:play nil\\n            \:discard nil\\n            \:trump nil\\n            \:misere nil\\n            })" "(newfunc mysit)" "(def var1 (create-module 5 \:play))" "(def var2 (create-module 5 \:play))" "(def var3 (crossover var1 var2 10))" "var3" "mysit" "(def mysit (let [temp (deal-hand (produce-deck) 13)]\\n             {\:play {\:suit 'Hearts  \:value 0}\\n              \:discard (butlast temp)\\n              \:hand (butlast (deal-hand (last temp) 13))\\n              \:trump 'Hearts\\n              \:misere false\\n              }))" "(def myfunc3 (compile-module var3))" "(myfunc3 mysit)" "(def mysit (let [temp (deal-hand (produce-deck) 13)]\\r\\n                {\:play {\:suit 'Hearts  \:value 10}\\r\\n                 \:discard (butlast temp)\\r\\n                 \:hand (butlast (deal-hand (last temp) 13))\\r\\n                 \:trump 'Hearts\\r\\n                 \:misere false\\r\\n                 }))" "(myfunc3 mysit)" "(def var1 (create-module 3 \:play))" "(def var2 (create-module 3 \:play))" "(def var3 (crossover var1 var2 4))" "var3" "(def myfunc3 (compile-module var3))" "(myfunc3 mysit)" "(host-tournament (create-generation 128 3 3 3 3 3 5 5) 7)" "(host-tournament (create-generation 128 3 3 3 3 3 5 5) 8)" "(Math/random)" "(log2 128)" "(nth '(1 2 3 4 5 6 7 8 9 0) (log2 32))" "(log2 130)" "(nth '(1 2 3 4 5 6 7 8 9 0) (log2 33))" "(nth '(1 2 3 4 5 6 7 8 9 0) (log2 50))" "(nth '(1 2 3 4 5 6 7 8 9 0) (log2 60))" "(nth '(1 2 3 4 5 6 7 8 9 0) (log2 63))" "(if (> 0.5 (Math/random)) (let [x (* 10 (Math/random))] (print x) 'a) 'b)" "(let [x (Math/random)] (if (> 0.5 x) 'a 'b (print (* 10 x))) (print x))" "(let [x (Math/random)] (if (> 0.5 x) 'a 'b) (print x))" "(let [x (Math/random)] (if (> 0.5 x) (print 'a) (print 'b)) (print x))" " (let [x (Math/random)] (if (> 0.5 x) (print 'a) (print 'b)) (print x))" "(defn recursive [steps x] \\n  (cond (\= 0 steps) '(x)\\n        (\= 10 steps) (concat '(x) (recursive (dec steps) (inc x)))\\n        \:else (recursive (dec steps) (inc x))\\n    ))" "(recursive 20 5)" "(defn recursive [steps x] \\r\\n     (cond (\= 0 steps) (list x)\\r\\n           (\= 10 steps) (concat (lsit x) (recursive (dec steps) (inc x)))\\r\\n           \:else (recursive (dec steps) (inc x))\\r\\n       ))" "(defn recursive [steps x] \\r\\n        (cond (\= 0 steps) (list x)\\r\\n              (\= 10 steps) (concat (list x) (recursive (dec steps) (inc x)))\\r\\n              \:else (recursive (dec steps) (inc x))\\r\\n          ))" "(recursive 20 5)" "(genetic-programming 1024 50 2 3 3 3 3 3 5 5)" "(nil 2)" "(dotrace [genetic-programming] (genetic-programming 128 20 3 3 3 3 3 5 5))" "(dotrace [genetic-programming] (genetic-programming 128 20 2 3 3 3 3 3 5 5))" "(dotrace [genetic-programming] (genetic-programming 8 10 2 3 3 3 3 3 5 5))" "(dotrace [genetic-programming] (genetic-programming 8 5 2 3 3 3 3 3 5 5))" "(def mymap {\:a 1 \:b 2})" "(mymap nil)" "(genetic-programming 8 5 2 3 3 3 3 3 5 5)" "(genetic-programming 1024 50 2 3 3 3 3 3 5 5)" "(System/exit)" "(genetic-programming 10 2 2 3 3 3 3 3 5 5)" "(play-verbose (compile-player (create-player-trees 2 3 3 3 3 5 5)) (compile-player (create-player-trees 2 3 3 3 3 5 5)))" "(remove-group (list {\:suit 'Hearts \:value 10} {\:suit 'Diamonds \:value 10}) (produce-deck))" "(play-verbose (compile-player (create-player-trees 2 3 3 3 3 5 5)) (compile-player (create-player-trees 2 3 3 3 3 5 5)))" "(play-verbose (compile-player (create-player-trees 3 3 3 3 3 5 5)) (compile-player (create-player-trees 3 3 3 3 3 5 5)))" "(isdiscard? '({\:suit 'Hearts \:value 2}\\n               {\:suit 'Hearts \:value 7}\\n               {\:suit 'Hearts \:value 6}\\n               {\:suit 'Hearts \:value 5}\\n               {\:suit 'Hearts \:value 4}\\n               {\:suit 'Hearts \:value 3}))" "(def mysit (let [temp (deal-hand (produce-deck) 12)] {\:hand (butlast temp)\\n                                                      \:discard nil\\n                                                      \:play null-card\\n                                                      \:trump 'Hearrts\\n                                                      \:misere false}))" "(def myvar (create-module 2 \:discard))" "myvar" "(def myfunc (compile-module myvar))" "(myfunc mysit)" "(isdiscard? (myfunc mysit))" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(remove-group (myfunc mysit) (produce-deck))" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(create-player-trees 2 2 2 2 2 2 2)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(create-player-trees 2 2 2 2 2 2 2)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(def mypl1 (create-player-trees 2 2 2 2 2 2 2))" "(def mypl2 (create-player-trees 2 2 2 2 2 2 2))" "(mypl1 \:discard)" "(def myplfun1 (compile-player mypl1))" "(def mysit (let [temp (deal-hand (produce-deck) 12)] {\:discard nil \:hand (butlast temp) \:play null-card \:trump 'Hearts \:misere false} ))" "(isdiscard? ((myplfun1 \:discard) mysit))" "(play-verbose mypl1 mypl2)" "(def myplfun2 (compile-player mypl2))" "(isdiscard? ((myplfun2 \:discard) mysit))" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(def mysit2 {\:play {\:suit nil, \:value 0}, \:hand ({\:suit Clubs, \:value 7} {\:suit Spades, \:value Jack} {\:suit Clubs, \:value 9} {\:suit Diamonds, \:value 10} {\:suit Spades, \:value King} {\:suit Diamonds, \:value 4} {\:suit Spades, \:value 10} {\:suit Hearts, \:value 2} {\:suit Hearts, \:value 10} {\:suit Clubs, \:value King} {\:suit Clubs, \:value Jack} {\:suit Hearts, \:value Jack}), \:discard (), \:misere false, \:trump nil})" "(def mysit2 {\:play {\:suit nil, \:value 0}, \:hand ({\:suit 'Clubs, \:value 7} {\:suit 'Spades, \:value 'Jack} {\:suit 'Clubs, \:value 9} {\:suit 'Diamonds, \:value 10} {\:suit 'Spades, \:value 'King} {\:suit 'Diamonds, \:value 4} {\:suit 'Spades, \:value 10} {\:suit 'Hearts, \:value 2} {\:suit 'Hearts, \:value 10} {\:suit 'Clubs, \:value 'King} {\:suit 'Clubs, \:value 'Jack} {\:suit 'Hearts, \:value 'Jack}), \:discard (), \:misere false, \:trump nil})" "(def mysit2 {\:play {\:suit nil \:value 0} \:hand ({\:suit 'Clubs \:value 7} {\:suit 'Spades \:value 'Jack} {\:suit 'Clubs \:value 9} {\:suit 'Diamonds \:value 10} {\:suit 'Spades \:value 'King} {\:suit 'Diamonds \:value 4} {\:suit 'Spades \:value 10} {\:suit 'Hearts \:value 2} {\:suit 'Hearts \:value 10} {\:suit 'Clubs \:value 'King} {\:suit 'Clubs \:value 'Jack} {\:suit 'Hearts \:value 'Jack}) \:discard () \:misere false \:trump nil})" "(def mysit2 {\:play {\:suit nil \:value 0} \:hand '({\:suit 'Clubs \:value 7} {\:suit 'Spades \:value 'Jack} {\:suit 'Clubs \:value 9} {\:suit 'Diamonds \:value 10} {\:suit 'Spades \:value 'King} {\:suit 'Diamonds \:value 4} {\:suit 'Spades \:value 10} {\:suit 'Hearts \:value 2} {\:suit 'Hearts \:value 10} {\:suit 'Clubs \:value 'King} {\:suit 'Clubs \:value 'Jack} {\:suit 'Hearts \:value 'Jack}) \:discard () \:misere false \:trump nil})" "(def mypl1 (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "((mypl1 \:discard) mysit2)" "(list)" "(print mysit2)" "(isdiscard? ((mypl1 \:discard) mysit2))" "(try-catch (mypl1 \:discard) mysit2 isdiscard?)" "(play-verbose mypl1 mypl1)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(def mypl (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "((mypl \:mode) mysit)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit)" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit modes)" "(first modes)" "(nth modes 1)" "(last modes)" "(count modes)" "(def pl1 (create-player-trees 2 2 2 2 2 2 2))" "(pl1 \:mode)" "(def pl1fun (compile-player pl1))" "((pl1fun \:mode) mysit)" "((pl1fun \:mode) mysit modes)" "(list 'fn ['situation 'modes]\\r\\n                     (list 'let \\r\\n                           ['play (list 'situation \:play)\\r\\n                           'hand (list 'situation \:hand)\\r\\n                           'discard (list 'situation \:discard)\\r\\n                           'misere (list 'situation \:misere)\\r\\n                           'trump (list 'situation \:trump)]\\r\\n                     tree) )" "(list 'fn ['situation 'modes]\\r\\n                     (list 'let \\r\\n                           ['play (list 'situation \:play)\\r\\n                           'hand (list 'situation \:hand)\\r\\n                           'discard (list 'situation \:discard)\\r\\n                           'misere (list 'situation \:misere)\\r\\n                           'trump (list 'situation \:trump)]\\r\\n                     'tree) )" "(eval (list 'fn ['situation 'modes]\\r\\n                        (list 'let \\r\\n                              ['play (list 'situation \:play)\\r\\n                              'hand (list 'situation \:hand)\\r\\n                              'discard (list 'situation \:discard)\\r\\n                              'misere (list 'situation \:misere)\\r\\n                              'trump (list 'situation \:trump)]\\r\\n                        'tree) ))" " (eval (list 'fn ['situation 'modes]\\r\\n                           (list 'let \\r\\n                                 ['play (list 'situation \:play)\\r\\n                                 'hand (list 'situation \:hand)\\r\\n                                 'discard (list 'situation \:discard)\\r\\n                                 'misere (list 'situation \:misere)\\r\\n                                 'trump (list 'situation \:trump)]\\r\\n                           (list + 1 1)) ))" "(def dummy (eval (list 'fn ['situation 'modes]\\r\\n                              (list 'let \\r\\n                                    ['play (list 'situation \:play)\\r\\n                                    'hand (list 'situation \:hand)\\r\\n                                    'discard (list 'situation \:discard)\\r\\n                                    'misere (list 'situation \:misere)\\r\\n                                    'trump (list 'situation \:trump)]\\r\\n                              (list + 1 1)) ))\\n  )" "(dummy mysit modes)" "(def dummy (eval (list 'fn ['situation 'modes]\\r\\n                                 (list 'let \\r\\n                                       ['play (list 'situation \:play)\\r\\n                                       'hand (list 'situation \:hand)\\r\\n                                       'discard (list 'situation \:discard)\\r\\n                                       'misere (list 'situation \:misere)\\r\\n                                       'trump (list 'situation \:trump)]\\r\\n                                 modes) ))\\r\\n     )" "(def dummy (eval (list 'fn ['situation 'modes]\\r\\n                                    (list 'let \\r\\n                                          ['play (list 'situation \:play)\\r\\n                                          'hand (list 'situation \:hand)\\r\\n                                          'discard (list 'situation \:discard)\\r\\n                                          'misere (list 'situation \:misere)\\r\\n                                          'trump (list 'situation \:trump)]\\r\\n                                    'modes) ))\\r\\n        )" "(dummy mysit modes)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit modes)" "(first nil)" "(count nil)" "(nth nil 2)" "(if nil 1 2)" "(cond nil 1 true 2)" "(def mysit2 (let [temp (deal-hand (produce-deck) 12)] {\:discard nil \:hand (butlast temp) \:play null-card \:trump modes \:misere false} ))" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit2 modes)" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit2)" "(\= nil 0)" "(\= 0 (first nil))" "(nth '() 2)" "(nth nil 2)" "(nth '(nil) 2)" "(cond nil nil)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit allmodes)" "(nil 2)" "('() 2)" "(defn myfun (eval (list 'fn ['situation 'modes]\\r\\n                     (list 'let \\r\\n                           ['play (list 'situation \:play)\\r\\n                           'hand (list 'situation \:hand)\\r\\n                           'discard (list 'situation \:discard)\\r\\n                           'misere (list 'situation \:misere)\\r\\n                           'trump (list 'situation \:trump)]\\r\\n                     'modes) )))" " (def myfun (eval (list 'fn ['situation 'modes]\\r\\n                        (list 'let \\r\\n                              ['play (list 'situation \:play)\\r\\n                              'hand (list 'situation \:hand)\\r\\n                              'discard (list 'situation \:discard)\\r\\n                              'misere (list 'situation \:misere)\\r\\n                              'trump (list 'situation \:trump)]\\r\\n                        'modes) )))" "(myfun mysit allmodes)" "(inc (last '()))" "(\= 0 (count '()))" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit allmodes)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:modes) mysit allmodes)" "((create-player-trees 2 2 2 2 2 2 2) \:modes)" "((create-player-trees 2 2 2 2 2 2 2) \:play)" "(create-player-trees 2 2 2 2 2 2 2)" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit allmodes)" "((create-player-trees 2 2 2 2 2 2 2) \:mode)" "(def myfun (compile-mode ((create-player-trees 2 2 2 2 2 2 2) \:mode)))" "(myfun mysit allmodes)" "(def myfun (compile-mode ((create-player-trees 2 2 2 2 2 2 2) \:mode)))" "(myfun mysit allmodes)" "(myfun mysit (remove-mode 'misere allmodes))" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(genetic-programming 10 5 2 2 2 2 2 2 2 2)" "(def myplx {\:discard\\r\\n  (discard-random\\r\\n   (return-hand\\r\\n    (return-hand (return-hand hand)))),\\r\\n  \:peek\\r\\n  (has-trump\\r\\n   (take-n\\r\\n    (get-suits hand 'Clubs trump)\\r\\n    (low-cards-num discard))\\r\\n   (return-trump\\r\\n    (return-trump trump))),\\r\\n  \:mode\\r\\n  (select-mode\\r\\n   (\= 4 2)\\r\\n   (< 6 13)\\r\\n   (> 1 2)\\r\\n   (return-modes modes)),\\r\\n  \:choice\\r\\n  (select-choice\\r\\n   (has-trump\\r\\n    (high-cards hand)\\r\\n    (return-trump trump))\\r\\n   (is-trump\\r\\n    (get-nth-lowest-from-suit\\r\\n     discard\\r\\n     trump\\r\\n     4)\\r\\n    (return-trump trump))\\r\\n   (has-low-cards hand)\\r\\n   (>\\r\\n    (high-cards-num discard)\\r\\n    (parse-value play misere))\\r\\n   (lead-wins-against?\\r\\n    play\\r\\n    play\\r\\n    trump\\r\\n    misere)\\r\\n   (has-high-cards (high-cards hand))\\r\\n   (is-misere misere)),\\r\\n  \:lead\\r\\n  (wins-by-value?\\r\\n   (get-nth-lowest-from-suit\\r\\n    hand\\r\\n    'Clubs\\r\\n    13)\\r\\n   (get-highest-from-suit\\r\\n    (get-suit-2 hand 'Spades)\\r\\n    (get-most-suit discard))\\r\\n   (is-misere misere)),\\r\\n  \:dolead\\r\\n  (get-nth-highest-from-suit\\r\\n   (low-cards hand)\\r\\n   (select-suit\\r\\n\\r\\n    misere\\r\\n    misere\\r\\n    true\\r\\n    misere)\\r\\n   (high-cards-num discard)),\\r\\n  \:respond\\r\\n  (get-nth-highest-from-suit\\r\\n   (take-n\\r\\n    (get-most-suit-2 hand)\\r\\n    (parse-value play misere))\\r\\n   (select-suit\\r\\n    (is-misere misere)\\r\\n    (has-trump discard trump)\\r\\n    (is-misere misere)\\r\\n    (is-suit play trump))\\r\\n   (high-cards-num\\r\\n    (get-suit discard play)))})" "(def myplx (first (genetic-programming 10 5 2 2 2 2 2 2 2 2)))" "(def myplxfun (compile-player myplx))" "(play-verbose myplxfun myplxfun)" "((myplxfun \:mode) mysit allmodes)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(def mysit2 {\:play {\:suit nil \:value 0} \:hand ({\:suit 'Clubs \:value 6} {\:suit 'Diamonds \:value 2} {\:suit 'Diamonds \:value 9} {\:suit 'Diamonds \:value 5} {\:suit 'Spades \:value 'Ace} {\:suit 'Spades \:value 3} {\:suit 'Clubs \:value 10} {\:suit 'Hearts \:value 6} {\:suit 'Clubs \:value 'King} {\:suit 'Clubs \:value 5} {\:suit 'Clubs \:value 7} {\:suit 'Clubs \:value 4}) \:discard () \:misere false, \:trump nil})" "(def mysit2 {\:play {\:suit nil \:value 0} \:hand ({\:suit 'Clubs \:value 6} {\:suit 'Diamonds \:value 2} {\:suit 'Diamonds \:value 9} {\:suit 'Diamonds \:value 5} {\:suit 'Spades \:value 'Ace} {\:suit 'Spades \:value 3} {\:suit 'Clubs \:value 10} {\:suit 'Hearts \:value 6} {\:suit 'Clubs \:value 'King} {\:suit 'Clubs \:value 5} {\:suit 'Clubs \:value 7} {\:suit 'Clubs \:value 4}) \:discard () \:misere false \:trump nil})" "(def mysit2 {\:play {\:suit nil \:value 0} \:hand '({\:suit 'Clubs \:value 6} {\:suit 'Diamonds \:value 2} {\:suit 'Diamonds \:value 9} {\:suit 'Diamonds \:value 5} {\:suit 'Spades \:value 'Ace} {\:suit 'Spades \:value 3} {\:suit 'Clubs \:value 10} {\:suit 'Hearts \:value 6} {\:suit 'Clubs \:value 'King} {\:suit 'Clubs \:value 5} {\:suit 'Clubs \:value 7} {\:suit 'Clubs \:value 4}) \:discard () \:misere false \:trump nil})" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit allmodes)" " (((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit allmodes)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit2 allmodes)" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit allmodes)" "(def mypl1 (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "((mypl1 \:mode) mysit allmodes)" "((mypl1 \:mode) mysit2 allmodes)" "(def mywinner (first (genetic-programming 100 20 2 2 2 2 2 2 2 2)))" "(play-verbose mywinner mywinner)" "((mywinner \:mode) mysit allmodes)" "(play-verbose (compile-player mywinner) (compile-player mywinner))" "(((compile-player mywinner) \:mode) mysit allmodes)" "(((compile-player mywinner) \:mode) mysit2 allmodes)" "(play-verbose (compile-player mywinner) (compile-player mywinner))" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit2 allmodes)" "(.get() clojure.lang.PersistentArrayMap \:mode)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(def mypl (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(get mypl \:mode)" "(find \:mode)" "(find-keyword test-test.core \:mode)" "(find-keyword 'test-test.core \:mode)" "(find-keyword \\"test-test.core\\" \:mode)" "(find-keyword \\"test-test.core\\" \\"mode\\")" "(get mypl \\"mode\\")" "(get mypl \:mode)" "(clojure.lang.Keyword/find \\"mode\\")" "(clojure.lang.Keyword/find \\"test-test.core\\" \\"mode\\")" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit2 allmodes)" "(def mywinners (genetic-programming 100 20 2 2 2 2 2 2 2 2))" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(genetic-programming 100 20 2 2 2 2 2 2 2 2)" "(genetic-programming 10 5 2 2 2 2 2 2 2 2)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(((compile-player (create-player-trees 2 2 2 2 2 2 2)) \:mode) mysit2 allmodes)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(genetic-programming 100 30 2 2 2 2 2 2 2 2)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(genetic-programming 10 5 2 2 2 2 2 2 2 2)" " (genetic-programming 10 5 2 2 2 2 2 2 2 2)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(print \\"ok\\")" "(genetic-programming 10 5 2 2 2 2 2 2 2 2)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(print \\"ok\\")" "(genetic-programming 10 5 2 2 2 2 2 2 2 2)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(def mywinner (first (genetic-programming 100 20 2 2 2 2 2 2 2 2)))" "(play-verbose (compile-player mywinner) (compile-player mywinner))" "(print 1 \\"+\\" 2)" "(compare-generations 10 50)" "(genetic-programming 10 5 2 2 2 2 2 2 2 2)" "(def mywinner (first (genetic-programming 100 20 2 2 2 2 2 2 2 2)))" "(play-verbose (compile-player mywinner) (compile-player mywinner))" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(things 3)" "(defn things)" "((defn things) 3)" "((defn things []) 3)" "((defn things [x]) 3)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "val" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(concat '(1) '(2) '(3))" "(genetic-programming 10 5 2 2 2 2 2 2 2 2)" "(compare-generations 10 20)" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "val" "(play-verbose (compile-player (create-player-trees 2 2 2 2 2 2 2)) (compile-player (create-player-trees 2 2 2 2 2 2 2)))" "(compare-generations 50 70)" "(string \\"generation\\" 1)" "(print \\"\\\\ngeneration \\" 1 \\" won \\" 50 \\" out of 100 times\\\\ngeneration \\" 2 \\" won \\" 50 \\" out of 100 times\\\\n\\")" "(compare-generations 10 5)" "(compare-generations 10 20)" "(compare-generations 5 10)" "(compare-generations 20 10)" "(compare-generations 20 5)" "(compare-generations 5 20)" "(compare-generations 30 2)" "(compare-generations 2 30)" "(compare-generations 5 10)" "(create-statistics 50)" "(create-statistics 30)" "(first 1)" "(genetic-programming 10 5 2 2 2 2 2 2 2 2)" "(empty? 4)" "(dotrace [host-tournament] (compare-generations 10 50))" "(create-statistics 50)" "(create-statistics 30)" "(create-generation 25)" "(create-statistics 25)" "(dotrace [host-tournament] (create-statistics 25))" "(first {\:a 1 \:b 2})" "(first 'a)" "(create-statistics 10)" "(create-statistics 30)" "(dotrace [compare-generations] (create-statistics 10))" "(dotrace [tournament-round] (create-statistics 20))" "(seq? '(1 2))" "(+ 1 1)" "(create-statistics 10)" "(create-statistics 50)" "(create-statistics 20)"]
eclipse.preferences.version=1
